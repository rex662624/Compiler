/* Definition section */
%{
	#include <stdio.h>
	#include <stdlib.h>
	#define TableSize 100
	#include "y.tab.h"  /* header file generated by bison */
	/* Symbol table function */
	
	extern void create_symbol();
 	extern void insert_symbol(char*,int);
 	extern int lookup_symbol(char*);
 	extern void dump_symbol();


	extern int linecount;
	extern int commentline; 
	int varflag=0;/*要開始宣告*/
	char * nowid = NULL;
		

	
	typedef struct symbol_table{
	char* id;
	char* type;
	int vaild;
	}symboltable;
	symboltable* table[TableSize];
	extern int CreateTableFlag;	
	extern int CheckUndefined;
	int doubleComment=0;//查看是否有同一行複數個comment
	/*-------NEW----*/
	extern YYSTYPE yylval; //YYSTYPE

	extern int yylineno;//行數

	void AllocAndCopy(char*);

%}

/* Define regular expression label */

letter [a-zA-Z]
digit [0-9]
id {letter}+({letter}|{digit})*
floatdigit [0-9]+"."[0-9]+
number {digit}+|{floatdigit}
integer     {digit}+
double {digit}+"."{digit}+

%option yylineno

%x COMMENT STRING_STATE

/* Rules section */
%%

 /* Arithmetic */
"+"     { return ADD; }
"-" 	{ return SUB; }
"*" 	{ return MUL; }
"/" 	{ return DIV; }
"%"     { return MOD; }
"++"    { return INC; }
"--"    { return DEC; }

 /* Relational */
">"		{ return GT; }
"<"		{ return LT; }
">="	{ return GE; }
"<="	{ return LE; }
"=="	{ return EQ; }
"!="	{ return NE; }

 /* Assignment */
"="		{ return ASSIGN; }
"+="	{ return ADD_ASSIGN; }
"-="	{ return SUB_ASSIGN; }
"*="	{ return MUL_ASSIGN; }
"/="	{ return DIV_ASSIGN; }
"%="	{ return MOD_ASSIGN; }

 /* Logical */
"&&"	{ return AND; }
"||"	{ return OR; }
"!" { return NOT; }


"("		{ return '('; }
")"		{ return ')'; }
"{"		{ return LB2; }
"}" { return RB2; }


 /* Print Keywords */	
"print" {return PRINT;}
"println" { return PRINTLN; }

 /* Condition and Loop Keywords */
"if"		{ return IF; }
"else"		{ return ELSE; }
"for"		{ return FOR; }


 /* Declaration Keywords */
"var"     {varflag = 1 ;AllocAndCopy(yytext); 
	//	printf("--------------VAR\n");
			return VAR;}
"void"    {AllocAndCopy(yytext); return VOID;}
"int"     {
		
		if(varflag==1){
//			printf("%s \t int TYPE VAR\n",nowid);
			insert_symbol(nowid,0);
		}	
		varflag=0;free(nowid);
		AllocAndCopy(yytext); 
	//	printf("-----------------INT\n");	
		return INT;
	}
"float32" {
                if(varflag==1){
//	                printf("%s \t float TYPE VAR\n",nowid);
			insert_symbol(nowid,1);
                }
            varflag=0;free(nowid);
			AllocAndCopy(yytext); return FLOAT;

        }


\"[^\n"]+\" {
			//防止memory leak 再重新malloc 並copy
			AllocAndCopy(yytext);
			return STRING;}

{integer}	{ sscanf(yytext,"%d",&yylval.val.i_val);
				yylval.val.type=1;
				return I_CONST;
			}
{double}	{ sscanf(yytext,"%lf",&yylval.val.f_val);
				yylval.val.type=0;
				return F_CONST;
}





"//".*	{printf("%s \t C++ Comment \n",yytext);commentline++;
	if(doubleComment==1)commentline--;
	
	return C_COMMENT;
	}

"/""*"[^*]*[*]+([^*/][^*]*[*]+)*"/" {//註解
		printf("%s \t C++ Comment \n",yytext);
		commentline++;
		//解決一行有兩個以上的註解
		if(doubleComment==1)commentline--;
		//解決註解橫跨多行
		int i ;
                for(i=0;i<yyleng;i++)
                        if(yytext[i]=='\n')
				{
					commentline++;
					linecount++;
				}
		
		doubleComment=1;
		return C_COMMENT;
		}

{id}	{
	if(varflag==1){//如果是宣告
		nowid = malloc(strlen(yytext)+1);
		strcpy(nowid,yytext);
	}
	else{
		printf("%s \t ID \n", yytext);
		if(CreateTableFlag==0){//table連建都沒建 一定undefined
		printf("Error:Undefined variable %s\n",yytext);
		}
		else{//否則查表看是否是undefined variable
		CheckUndefined = 1;
		lookup_symbol(yytext);
		CheckUndefined = 0;		
		}
		printf("-------------ID\n");	
	}
	AllocAndCopy(yytext);return ID;
	}



[\n]		{linecount++; varflag = 0;nowid=NULL;doubleComment=0;
				yylineno++;
				return NEWLINE;}
[ \t]		{;} /* Ignore */
[^; \t] 	{;} /* Ignore other charactor sets */
<<EOF>> {yyterminate();}



%%

/*	C Code section */
int yywrap(void)
{
    return 1;
}

void AllocAndCopy(char * yytext){//先free掉原來的再new新的
//    if(yylval.string) free(yylval.string); free掉會出錯(有空搞懂)
    yylval.string=malloc(sizeof(yytext+1));
	strcpy(yylval.string,yytext);
} 
